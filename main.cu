#include "kernel.h"
#include "params.h"
#include "kem.h"
#include "speed.h"
#include <iostream>
#include "./poly_mul_n653q/n653.h"
#include "poly.h"
#include "tensor.h"

using namespace std;

#define HXWTEST 1
//int16_t coe1[FPTRU_N]={-273,-190,-148,-140,266,290,142,-246,-348,-162,88,-168,-188,-106,-312,-36,60,-112,86,244,-50,-92,-28,124,296,104,-238,20,476,224,-172,-270,-406,-162,-180,-134,34,0,292,88,-4,10,-10,-114,-238,-196,26,74,-52,-28,340,258,-170,168,88,-48,-8,-224,-358,36,32,58,44,-386,-242,-316,-374,348,222,-290,170,124,-266,-316,-116,-84,-36,-142,-174,-166,-2,-14,-298,-12,-18,-436,-96,84,-254,-174,-276,-458,-252,186,-66,-182,-144,136,-60,-94,-182,-148,-34,508,96,-132,-182,16,-34,-434,-120,-230,140,188,270,-94,-218,-254,-194,-348,58,-362,-220,-178,-34,6,-54,32,158,356,164,318,158,-374,-380,134,98,136,-166,128,-314,-606,12,138,266,500,362,-254,-60,324,-58,192,496,168,66,-26,-146,-256,14,184,24,-224,-70,-150,56,166,-6,20,-90,-216,-134,132,-8,-90,-236,100,-34,34,138,118,0,36,-92,42,-462,-296,312,-8,330,266,240,384,264,-174,242,486,406,140,298,94,216,-128,-54,418,574,362,164,36,-128,222,40,-122,70,148,-24,210,-30,-16,-214,-138,-322,-256,-196,-290,-24,96,132,150,-4,4,74,224,0,-188,-18,56,410,466,370,414,84,124,28,-146,-26,196,254,-24,-346,168,488,354,448,158,36,176,4,-160,-186,268,138,-56,-288,-342,-186,-310,-264,-218,194,132,-202,-630,-152,-88,-50,192,182,122,-44,-178,-268,252,170,78,222,-70,-438,56,38,46,162,298,120,84,-4,-86,196,-64,-50,4,-10,168,-36,68,-118,-118,20,-10,-156,-218,100,168,44,114,-102,-72,386,-90,-408,-192,-94,-104,82,-118,16,-140,-150,-16,-146,-370,-242,-112,-108,-78,-316,-338,10,-78,164,12,-260,-36,-220,-422,-92,-164,198,224,74,-138,266,-36,216,410,46,-46,164,20,352,36,-178,-42,-242,-14,-190,-138,-70,46,-154,150,-58,-388,-304,128,188,8,100,-152,16,-12,-248,-156,-84,-232,20,-62,-176,178,18,128,198,190,22,96,-154,-16,-114,-38,244,14,56,306,178,-178,-384,-152,96,98,182,-74,-40,-426,-348,84,96,-14,-28,140,94,-396,-232,-24,50,-166,-100,-318,-76,-350,-128,-74,44,-48,-112,-242,-206,156,-132,-94,-128,20,-8,284,-24,-316,176,32,-528,24,306,432,472,-64,-92,300,30,96,56,218,68,260,0,-86,196,164,8,44,-62,22,-192,286,30,-184,-410,-172,-126,108,-244,116,-34,-118,-78,-30,-220,-14,-138,-254,130,366,-8,80,402,272,178,-152,162,282,-94,16,26,-130,174,102,46,38,-256,50,30,-136,-200,32,-204,2,-116,2,-68,-34,-180,-28,72,-212,-274,158,56,194,16,-108,254,-118,4,-218,-34,38,90,-8,426,136,-256,228,232,200,272,36,-56,342,56,106,184,-176,308,210,400,40,172,-122,156,-178,302,100,-204,-88,-204,-328,260,-358,40,-312,-48,-56,-244,38,336,-224,224,130,60,-96,-214,-86,-68,114,52,-24,34,-206,-62,-212,210,-92,-148,-30,48,26,-204,-130,78,282,26,106,28,280,-64,12,212,340,-86,122,176,-88,96,-130,-384,58,248,-20,54,72,-62,-16,78,318,-82,-16,-34,108,80,-272,-66,24,322,158,222,60,-314,-110,102,0,-14,-10,-40,198,-286,110,42,170,-126,440,-108,-166,104,-224,242,38,-98};
//int16_t coe2[FPTRU_N] = {-1,-2,-2,-4,0,-2,0,-4,0,4,0,-4,0,2,-4,-2,6,0,2,2,-2,0,0,0,-4,0,0,-2,2,0,-2,0,0,0,-6,4,0,0,0,-4,4,0,2,-4,-2,2,2,-2,0,-2,-2,4,-2,0,2,-2,2,4,0,0,-6,0,2,0,0,0,-2,-2,4,2,0,0,2,2,0,4,-4,-4,2,-4,-2,2,-2,-2,0,0,0,-4,0,2,2,0,0,-2,0,0,0,0,0,0,0,2,-2,-2,2,0,-2,0,0,4,-2,-2,-4,0,2,4,0,-4,2,2,-2,0,0,2,4,0,4,0,0,0,2,2,-4,2,2,2,0,2,4,-2,6,2,4,-2,0,-2,-2,-4,-2,0,0,0,4,2,4,-4,-2,-4,4,-4,2,-2,2,0,4,-4,0,0,0,4,0,0,0,0,4,2,0,0,0,-2,2,2,4,4,-2,2,-2,0,2,2,2,2,-2,0,0,2,4,-2,0,-2,2,0,-2,4,4,-2,-2,-4,-2,-2,-4,-2,4,2,-2,0,-2,-2,0,0,2,-4,0,4,0,0,4,-6,-2,-2,0,2,-2,0,0,-4,0,-2,4,0,-4,-4,0,0,-2,-2,0,0,-2,2,0,4,2,4,-2,2,4,-4,0,-4,2,0,2,2,-2,-2,2,4,-2,-4,4,0,2,-2,4,2,4,-2,-4,-4,2,2,-2,-2,-2,4,2,4,-4,-2,2,-2,2,-2,-2,6,0,-2,2,-4,2,0,0,0,2,0,2,2,0,0,-2,-4,2,0,-2,4,0,-2,-2,4,0,-2,-2,2,2,-2,2,0,-2,-4,0,6,0,-2,2,0,-6,-2,-2,-2,-6,2,0,2,2,-4,2,0,0,0,2,4,-2,4,4,-4,2,2,-2,-2,0,2,2,2,2,-2,2,2,4,0,2,2,6,4,-4,-2,-4,-2,-4,2,2,-6,0,0,4,-2,2,0,0,2,4,0,4,-2,-2,0,0,-4,-2,-4,0,0,-2,0,0,0,-4,2,0,2,2,-2,2,-4,4,0,-2,2,-2,0,0,2,4,-2,0,0,0,2,-4,2,2,-4,2,2,0,-6,-2,2,-2,-4,0,2,-2,0,-4,0,-2,2,4,-2,-2,-4,-2,-2,0,2,4,-2,-4,2,-4,4,2,2,4,2,2,0,0,4,0,-2,0,-2,-2,2,0,4,-2,-2,0,-2,0,-4,-4,-4,-2,0,0,2,0,2,-2,-4,-2,2,2,-2,0,2,-2,-2,4,-2,0,0,-2,-2,2,-2,0,-2,-2,-2,-2,4,2,2,0,2,-2,0,2,-6,4,-2,2,0,-4,2,0,-2,0,0,-2,4,-2,-4,-4,4,-4,-4,-2,4,2,0,-2,0,2,0,-4,0,-2,0,0,2,-4,4,-4,-4,-2,0,2,0,2,2,2,0,2,-2,-2,2,2,-2,-4,0,-6,0,-4,-2,-2,0,0,0,2,0,0,-4,4,-2,2,2,0,-2,2,-2,-4,4,-2,-2,-2,0,4,2,-2,0,2,-2,0,0,4,-2,-2,2,-4,0,0,-2,0,2,0,0,4,-2,-2,0,-4,2,4,2,2,-2,-4,4,-2,0,-2,2,2,-2,2,2,0,-2,-2,-4,0,-2,-4,-2,-4,2,0};
int16_t coe1[FPTRU_N]={1142,725,-21,681,-640,1967,-2199,-1080,1868,2139,-238,-1191,-592,1408,-637,222,-578,-272,1586,2154,244,-604,-1971,-528,-1654,-959,-1448,-1607,79,259,-2288,804,-792,874,1394,-106,1838,-581,-1984,2156,-760,1705,-1015,793,-1159,443,276,-1165,118,1861,-2289,-1727,-1255,-703,279,-150,-1602,-1630,-1661,-996,142,-410,2104,-571,-1667,-1868,-71,1715,209,1715,388,14,1957,1866,-1569,-1002,492,-1906,-76,283,-2177,605,1328,1109,-1049,899,-1054,1447,-1119,-1779,-1971,-1622,2133,-950,-238,1234,541,-1746,594,-918,-775,-2161,528,53,1887,931,279,972,509,1868,1685,1510,1585,-722,1355,-1370,1595,-1147,7,152,-439,-1598,-1770,-1149,-416,-618,2286,1793,2026,383,-1336,-372,1394,-1559,911,2060,2303,927,1000,-2071,-2090,-1685,12,287,315,-503,920,28,668,-1641,1388,1031,-1394,684,-1773,-2108,200,-1730,-1026,747,1013,848,1012,-1807,-695,-1882,-848,-1096,116,1128,-1231,-92,-2310,978,-2204,-539,1685,-2061,-753,-408,2159,1875,-987,1596,1631,-535,260,75,-220,2021,-685,2058,1510,1065,118,-2260,652,1455,1755,1657,-193,-275,-1718,10,1142,1143,-947,-367,502,-1617,-771,399,85,-570,-1765,1962,1462,499,-2011,491,-874,-67,-512,-476,1240,-874,-1147,1927,1457,1696,-1212,-1440,1368,-1727,-1146,2205,835,1478,-719,-215,-456,-892,268,-2069,-141,1814,-2219,2266,254,-360,1444,381,1929,158,-2125,2231,-1796,390,671,1739,-1625,-100,1003,-1065,-2194,-1842,1259,-793,1953,-1374,2162,-2025,-224,-491,-773,-1919,-1765,5,-775,-525,1694,-720,1914,1751,-1283,1050,-2242,1196,-2027,1052,-1210,1864,1302,-2149,-357,-1268,596,-179,-1469,2028,1078,-1810,-765,-2241,1358,727,-616,439,1486,1976,-211,1838,1194,-491,-165,-1752,827,-820,1991,-1764,1446,555,-2261,126,-1347,1512,461,1054,-1379,-1978,1066,1175,2081,876,1483,303,1913,-614,731,1515,1064,-342,-726,1450,1874,-1705,1057,-976,1485,-35,-573,-86,-878,-692,-2011,1379,-808,-130,1185,1719,-683,2013,-1613,2072,-919,846,1215,784,854,-114,2301,-494,-861,-93,-1404,75,2020,525,-2147,-1017,780,-1114,-1210,-927,-1684,-17,-1922,-910,-1945,-782,19,-1033,-823,1361,-806,471,-14,1021,1010,-1828,610,21,-184,-1345,1305,-1316,-2161,-193,-639,2269,-666,-419,1537,-691,1361,-728,937,1960,1468,-127,-1477,2099,1172,-1744,-1575,1524,2067,-1203,-90,1759,-1519,1191,1371,-2116,1402,-2145,1384,-1219,1148,-1212,-658,-2017,1550,0,-2245,14,-903,268,285,1502,-689,-1630,-2071,-599,338,-1189,1315,-559,1451,-1890,-357,900,1424,906,-948,-582,1189,-301,2026,306,-1830,703,-1765,417,-1028,-1437,-2015,868,1545,699,1587,-395,-2119,-1175,1420,-406,673,-784,-162,-127,2247,-2095,-78,-226,1692,-2306,1839,1860,-1453,-956,-136,1795,-186,-2062,-510,-2287,-1006,-1982,1078,1316,-2157,-479,-1257,-2271,2193,-913,1610,2269,1034,1864,1757,605,2195,1705,1710,-2155,-101,1483,-1017,-1301,-25,-318,-2283,-451,388,2049,2025,1302,-71,-2129,756,2024,872,-1140,734,-448,1716,-170,2274,1493,1953,-1438,-1785,-571,-1155,-2125,-2088,2085,-925,-1618,1274,-2006,618,844,1645,-560,1737,-2285,-1457,68,693,-124,1627,-1443,-1746,24,-477,-1045,-500,-596,428,1992,2128,1633,2243,514,1255,-1695,-899,672,-1258,762,-2096,-1156,421,-502,621,-1268,2064,-1709,1006,786,-2299,2213,1937,-1658,-1325,673,1583,844,1542,143,-77,999,-1601,-1656,1427,-1671,1201,1756,565,912,-1424,1277,1465,1734,-1132,186,2067,1146,-2010,-1938,-671,-865,-975,131,2263,-1236,456,1855,1067,1881,2047,1660,-1343,-1860,-501,-1372,-1049,1452,268,-1880,1499};
int16_t coe2[FPTRU_N] = {-3,2,-4,2,-2,2,2,2,2,2,-4,-2,-2,-2,-2,-2,4,0,2,-4,0,-2,0,-4,0,2,-4,0,-2,0,2,4,-6,4,-2,4,0,2,-4,2,-4,-2,-2,2,0,0,4,2,4,2,2,0,6,0,2,-6,2,-2,4,-2,0,-2,0,-2,2,0,4,4,0,-2,-4,-4,-2,-4,0,-4,0,-2,2,6,-2,0,-4,0,0,-4,2,2,-2,-2,0,2,0,0,4,-4,0,-4,2,-2,-4,-2,-2,4,4,0,4,-2,2,-2,0,2,-4,2,0,-2,0,4,0,0,-2,0,0,0,-6,-4,0,-2,-2,2,4,2,-4,0,0,0,-2,-2,4,4,0,0,0,-4,0,6,4,2,0,0,-4,-2,0,2,-2,6,-2,2,-2,-2,0,-2,0,0,0,-2,-2,-2,0,-2,-2,0,0,4,2,0,-4,-2,0,-4,0,-2,2,4,2,0,0,-2,0,2,-2,2,2,0,-4,2,2,0,2,-2,0,-2,0,-2,2,-2,-4,2,0,4,-2,2,4,2,0,-2,0,-2,-2,-4,0,0,2,-4,0,-2,0,-4,0,4,-2,-4,-2,2,0,-4,-2,4,-2,2,0,0,2,4,0,0,2,0,2,-2,2,6,-4,-2,6,-6,4,2,0,4,0,-2,2,2,2,0,-4,0,2,-2,2,-2,-2,-4,-2,4,-2,-2,-4,0,0,2,2,0,0,0,-2,2,2,2,0,2,-4,-2,-2,2,0,2,2,-4,2,-4,-2,0,4,-2,-2,0,4,0,0,-2,0,4,-2,0,4,0,-4,4,-2,4,-2,0,2,2,4,0,2,2,0,2,4,-4,0,0,-2,0,0,0,0,2,-2,2,-6,0,-2,0,-2,0,-2,2,0,-2,0,2,0,4,4,-2,2,4,0,2,0,-4,0,-2,0,0,2,-6,-2,-2,4,2,0,-2,4,0,0,0,-4,0,2,4,-4,-4,-2,2,4,0,0,2,-2,2,2,0,2,0,2,2,2,-2,0,4,-2,0,2,-4,0,2,-2,2,2,-6,-6,2,-2,2,2,0,4,-2,-4,2,0,-2,4,2,2,0,0,0,4,2,0,-2,0,2,-4,4,-2,-2,0,0,2,0,2,-4,-2,-2,0,-2,0,2,-2,0,0,4,4,2,4,0,-4,0,0,0,0,-2,0,2,-4,2,4,0,0,0,-2,-4,-2,2,-2,2,4,0,0,4,0,-4,0,2,0,0,2,-4,-2,-6,0,0,-4,4,0,-2,0,0,-4,0,0,0,4,0,-4,-2,-4,-2,-4,2,-2,2,0,6,4,-2,-6,2,4,2,-4,2,2,-2,2,0,2,4,0,0,4,0,-2,2,2,0,-4,2,0,0,2,-4,0,2,2,4,6,0,4,4,-2,-2,0,0,2,2,-2,2,0,2,-4,-4,4,2,2,0,-4,-2,-4,0,2,-2,-6,-2,2,-2,2,4,-4,2,2,0,0,-2,0,-2,-4,-6,-2,0,0,0,-2,0,2,2,4,-4,2,0,-2,4,-2,4,2,0,-2,4,-2,4,0,0,4,-2,-2,2,-2,2,-2,0,-2,2,2,0,-4,2,-4,0,4,-4,0,2,-4,-4,-2,2,-4,0,2,-2,2,0,-4,2,4};

unsigned char PK[FPTRU_KEM_PUBLICKEYBYTES]={0xb4,0x91,0x27,0xa2,0xd9,0xe9,0x41,0xb3,0x28,0x15,0x84,0x3c,0xd0,0x6f,0xe6,0x84,0xc,0xbe,0x3,0xe8,0x12,0x86,0x3e,0x95,0x5,0x37,0xa2,0xb3,0xe4,0x5d,0x84,0xf,0x8a,0xa5,0x6d,0x90,0xa9,0xdc,0x81,0x4,0x8b,0xbc,0xdf,0x55,0x73,0xc5,0xfe,0x58,0x13,0xd2,0xf8,0x4d,0x1d,0x17,0xec,0x43,0x16,0x12,0x84,0x26,0x3a,0xa3,0xcc,0xd5,0x8b,0xd2,0xf0,0x41,0x50,0x6c,0x6f,0xcf,0x55,0xa4,0x72,0xad,0x4d,0xd7,0xa3,0x66,0x59,0x69,0x30,0x50,0xf5,0x56,0xb5,0xbf,0x78,0x9e,0x80,0x7c,0x26,0xfa,0x77,0x56,0x92,0xa,0xf2,0x57,0xe,0xfd,0xc0,0xbf,0x4b,0x0,0x68,0x34,0x24,0x60,0x82,0xf3,0x8c,0x90,0xc1,0xa2,0x8a,0xcf,0xe3,0x6b,0x54,0xd0,0xdc,0xf1,0x6c,0xdf,0xc6,0xe4,0x68,0x5c,0xc5,0x47,0x1c,0x1f,0xee,0xd1,0x9e,0xb0,0x48,0x1c,0x8a,0xf5,0x45,0xf3,0x2,0x7a,0x84,0x43,0x3e,0x4b,0x82,0x53,0xd3,0x6d,0xed,0xbb,0x6c,0x82,0x25,0xc0,0x10,0xbb,0x96,0xd6,0xd0,0x44,0x5,0x92,0x85,0x65,0x4a,0x1b,0xef,0x5a,0x1c,0x99,0x1d,0x76,0xf1,0xd4,0x93,0x43,0x80,0x45,0x2b,0xff,0x48,0xbd,0x65,0x40,0x56,0xe1,0x6b,0xe2,0xee,0x3e,0x5,0xa4,0x5,0xcc,0xf0,0x7a,0x1b,0x34,0x54,0x3d,0x5d,0xcd,0x80,0x8c,0x4e,0x40,0x3b,0xb,0x5c,0xe7,0xb4,0x74,0xe1,0xf2,0x39,0x3,0x7f,0xf0,0x96,0x65,0x1d,0x22,0x5b,0x68,0x89,0xa1,0x32,0x46,0x46,0x2f,0xe2,0xe8,0xb1,0x73,0x7a,0x10,0xa5,0xb5,0xd1,0xbb,0x22,0x3f,0xc0,0xc2,0x1b,0x7b,0x8a,0x4d,0xc1,0x28,0x8a,0xad,0x8f,0xd8,0xc2,0x4f,0xe3,0xd2,0x4b,0x29,0xd0,0xb6,0x58,0x66,0x58,0x40,0x43,0x37,0x86,0xa3,0x5a,0x52,0xb4,0xb2,0x9d,0xe5,0xfd,0xd,0xc8,0xd1,0x23,0xd2,0x35,0xb,0xc7,0xdd,0xa9,0x6f,0x78,0x74,0x74,0x86,0xa8,0xcf,0x27,0xe4,0x1e,0xeb,0x1a,0x6e,0x1,0xf0,0xc3,0xa5,0xfc,0x2e,0x77,0xb8,0xfe,0x3b,0x1d,0x76,0xda,0x8e,0x2d,0xfc,0x78,0x5,0xc2,0x5d,0x42,0x4e,0x18,0xf6,0x86,0x23,0x62,0x86,0x95,0xdc,0xe1,0x93,0xe3,0x1e,0x5a,0x33,0x4f,0xa9,0x45,0x20,0x2d,0x19,0x1d,0xdf,0x51,0xcb,0x41,0xd0,0x50,0x47,0xf,0xcc,0x7a,0xbf,0xf1,0x1,0x71,0x26,0x12,0x64,0x4d,0xee,0x1d,0x6c,0xf9,0xc0,0x8d,0x5a,0x1d,0xc,0x72,0x38,0x9,0x3a,0x4,0xbf,0xe5,0x95,0x78,0xb8,0x54,0x1b,0x54,0xa3,0x41,0xdd,0x5f,0x1a,0x20,0xa0,0x88,0x81,0x7c,0x84,0x9,0xc2,0x6e,0xcf,0xa4,0xa4,0x17,0x61,0xdd,0xbc,0x6a,0x43,0xbe,0x5,0xd5,0xc5,0x94,0x5,0x82,0x3f,0x19,0x2b,0xb6,0x55,0x61,0xc7,0x2c,0xd,0x45,0x43,0x38,0x9a,0xd8,0x9d,0x64,0x8d,0xda,0x80,0x5d,0x96,0xa9,0xc9,0x52,0x85,0xc4,0x7c,0x5d,0xf9,0x88,0x87,0x7e,0xc9,0x59,0x34,0xbb,0xfd,0x2e,0x76,0x3,0xde,0xfd,0x5b,0x41,0x4c,0x7f,0x6c,0x7e,0xb9,0xc1,0x36,0x9,0xea,0x2b,0xc3,0x3e,0x12,0xea,0xba,0x90,0x1c,0xcd,0xde,0xb6,0x13,0x7c,0x14,0xc5,0xab,0xbe,0xec,0x60,0xef,0xa6,0x95,0xe4,0x7c,0x27,0x5,0xd8,0xdf,0xa,0xa8,0x97,0xa3,0xb1,0x16,0xb0,0xb0,0x9f,0xcb,0x80,0x84,0x2a,0xb6,0xe2,0xff,0x4a,0x7,0x51,0x3a,0xed,0x10,0xac,0x98,0xfc,0x34,0xd9,0xa2,0xf3,0xdf,0xef,0x46,0xd,0x3b,0xd7,0x1c,0x98,0xa0,0x9,0x9a,0xca,0xc6,0x6b,0x1,0x41,0xce,0x8f,0xc,0xec,0x70,0xae,0x50,0xa0,0xc2,0xbc,0xb5,0x13,0xd7,0x78,0x8f,0x71,0x76,0x33,0x21,0x7b,0x80,0x49,0xe5,0x91,0x63,0x38,0xe3,0x5e,0x6d,0xe3,0x35,0x1a,0x70,0x34,0xe3,0x62,0xf7,0x21,0xc1,0xfe,0x92,0x7a,0x49,0x7d,0x5a,0xfb,0xc1,0x73,0xf0,0xf6,0x66,0x23,0x36,0xa6,0x5b,0xa3,0x9a,0x35,0xeb,0x83,0xa5,0xd7,0x88,0x26,0xfe,0x35,0x26,0x66,0x58,0xad,0x75,0x85,0x47,0x11,0xd4,0x39,0x94,0x93,0x68,0xed,0xb3,0x11,0x40,0xe2,0xe8,0x96,0x53,0xa7,0xe3,0xd,0x4,0x1d,0xe1,0xbf,0x7a,0x76,0xda,0xba,0x14,0xd6,0xc7,0xad,0xa8,0x19,0x53,0x1e,0xe3,0x35,0x1c,0xc7,0x36,0xeb,0x8d,0x5e,0xf4,0x13,0x6,0x1e,0xcf,0x30,0x9b,0x7c,0xfa,0x7a,0xfe,0x74,0x2,0x46,0x13,0xfb,0x1,0x91,0x6e,0xe8,0x87,0x21,0x42,0x97,0xa3,0x4a,0xda,0x4e,0x3f,0x6b,0xff,0x67,0x99,0xcf,0x7a,0x48,0xf6,0x8f,0xc7,0x76,0x2f,0x14,0x15,0xe0,0xb,0xea,0x2d,0xe1,0xec,0xed,0xec,0x14,0xd6,0x80,0x62,0x45,0xe5,0xe,0x58,0x66,0x20,0xd,0xbf,0x21,0x78,0xb6,0xf,0x26,0x99,0x8d,0xa1,0x98,0xfd,0xfd,0x64,0x86,0xc4,0xea,0x3c,0xa8,0xcf,0xf0,0xc1,0x11,0x82,0x77,0xd7,0xd3,0x2d,0x7e,0x38,0x5e,0x62,0xd8,0x4b,0x19,0xc6,0x55,0x82,0x33,0xbc,0x7e,0xc1,0xc2,0xd,0xd0,0xac,0x9f,0x32,0xc1,0x76,0xad,0xf9,0xc9,0x30,0x54,0xc6,0x7,0xe5,0x69,0xb8,0x5a,0x30,0x1,0x25,0x4c,0xc1,0x13,0xa2,0x9e,0x15,0x95,0x48,0x75,0x8b,0x97,0x15,0xce,0x87,0xe0,0xb6,0xe,0x5b,0x94,0x45,0xcb,0x2a,0x6c,0x8e,0xc1,0x27,0x12,0xde,0xc4,0x94,0x3a,0x5c,0x63,0xfb,0x79,0x7b,0xf5,0x88,0xe,0x86,0xa8,0x56,0x77,0x10,0x77,0x82,0x47,0x30,0x81,0xfa,0xa8,0xd2,0xd6,0x80,0xba,0xb,0x1a,0x84,0xcb,0xac,0x6,0xac,0xbf,0xa6,0x57,0xc9,0x14,0xc7,0x1d,0xf7,0xc4,0xe7,0xff,0xb9,0xa5,0xf1,0x4c,0xaa,0xd2,0x9f,0x75,0x58,0x6c,0x4,0x89,0x7f,0x5,0xbd,0xf2,0x5b,0xb,0x76,0x58,0xba,0x6c,0x4a,0xe7,0x91,0x28,0x5f,0xec,0x34,0x3c,0x80,0x6a,0x1a,0xed,0x6e,0x39,0x1c,0xd3,0x23,0x38,0xec,0xa,0x51,0xa0,0x82,0xff,0x1a,0x5a,0x6b,0xaf,0x46,0xeb,0x64,0x92,0xec,0xa5,0xb5,0x3f,0x2,0x0,0xc2,0x46,0xac,0x82,0xaf,0x96,0x1c,0x69,0x4,0x9c,0xe1,0xa1,0xf5,0x2,0xca,0x82,0x8e,0x32,0x4e,0x4f,0x3e,0x6,0x8,0x1c,0xb9,0xc5,0xa7,0xbb,0x4,0xe8,0x3,0xac,0x83,0x89,0xc4,0xed,0x5f,0x9a,0x55,0x4b,0x17,0x79,0x8d,0xce,0x8b,0xff,0xc4,0x9f,0x77,0x1,0xe6,0xee,0x92,0xb4,0xfd,0xc5,0xc8,0x5b,0x7c,0x67,0xc5,0x4,0x94,0x12,0x82,0x8f,0x8e,0x7,0xf0,0x79,0xd1,0x15,0xd0,0x9,0x2e,0xb,0x32};

unsigned char SK[FPTRU_KEM_SECRETKEYBYTES]={0x3a,0x59,0x73,0x79,0xb7,0x95,0x75,0x75,0x79,0x77,0x59,0x73,0x7b,0x77,0x37,0x59,0x95,0xb3,0x59,0x53,0x95,0x9d,0x79,0x79,0x77,0x7b,0x5b,0x77,0x77,0x59,0x99,0x39,0x13,0x7b,0x97,0xb5,0x75,0x75,0x75,0x95,0x39,0x57,0x7b,0xdb,0x75,0x57,0x79,0x79,0x97,0xb9,0xb9,0x97,0x77,0xb7,0x77,0x39,0x57,0x97,0x75,0x77,0x9b,0x59,0x75,0x95,0x37,0xb7,0x97,0x77,0x57,0x57,0x37,0x77,0x95,0x57,0x75,0x55,0x9b,0x59,0xb7,0x73,0x99,0x79,0x75,0x37,0x5b,0x95,0x7b,0x53,0x37,0x79,0x99,0x9b,0x95,0x79,0x75,0x77,0x79,0x97,0x75,0x73,0x79,0x97,0x95,0x79,0x55,0xb5,0x37,0x79,0x97,0x9d,0x57,0x55,0x55,0x55,0x97,0x77,0x77,0x97,0x37,0x55,0x31,0x73,0x93,0x57,0x79,0x57,0x73,0x97,0x5b,0x75,0x95,0x97,0x77,0x3b,0x51,0xb5,0x99,0x99,0x75,0x9b,0xb5,0xb9,0x75,0x93,0x95,0x59,0x39,0x97,0x53,0x3b,0x79,0x79,0x55,0x5b,0x77,0x7b,0x73,0x73,0xb9,0x97,0x9b,0x73,0x77,0x77,0x79,0x55,0x1b,0x59,0x77,0x15,0x7b,0x3b,0x75,0x37,0x97,0x33,0x59,0x57,0x77,0x73,0x33,0xb7,0x95,0x39,0x99,0x35,0x3b,0x37,0x75,0x95,0x77,0x95,0x95,0x77,0x51,0x99,0x75,0x75,0xb9,0x57,0x57,0x77,0x77,0x37,0x99,0x55,0x39,0x33,0x99,0x77,0x9b,0x57,0x15,0x55,0x55,0xd5,0x99,0x55,0x73,0x95,0x55,0x37,0x77,0x57,0x7b,0xb3,0x79,0x59,0xb3,0x79,0x55,0xb1,0x73,0x55,0x55,0x97,0x53,0x59,0x97,0x39,0x97,0x79,0x75,0x5b,0x97,0x59,0x95,0x73,0x73,0x53,0x77,0x73,0x59,0xb7,0x79,0x37,0x95,0x77,0x93,0x37,0x95,0x97,0x33,0x95,0x95,0x71,0x57,0x55,0x57,0xb9,0x97,0x77,0x99,0x73,0x33,0xb7,0x59,0x59,0x57,0x53,0x57,0x57,0x59,0x97,0xbd,0x95,0x35,0x55,0x39,0x57,0x55,0x79,0x35,0x33,0x77,0x97,0x57,0x9b,0x93,0xb9,0x99,0xb7,0x97,0x57,0x57,0x79,0xbb,0x53,0x93,0x57,0x95,0x79,0x95,0x99,0x55,0x59,0x97,0x75,0x97,0x95,0xb5,0x59,0x79,0x57,0x77,0x79,0x5,0xb4,0x91,0x27,0xa2,0xd9,0xe9,0x41,0xb3,0x28,0x15,0x84,0x3c,0xd0,0x6f,0xe6,0x84,0xc,0xbe,0x3,0xe8,0x12,0x86,0x3e,0x95,0x5,0x37,0xa2,0xb3,0xe4,0x5d,0x84,0xf,0x8a,0xa5,0x6d,0x90,0xa9,0xdc,0x81,0x4,0x8b,0xbc,0xdf,0x55,0x73,0xc5,0xfe,0x58,0x13,0xd2,0xf8,0x4d,0x1d,0x17,0xec,0x43,0x16,0x12,0x84,0x26,0x3a,0xa3,0xcc,0xd5,0x8b,0xd2,0xf0,0x41,0x50,0x6c,0x6f,0xcf,0x55,0xa4,0x72,0xad,0x4d,0xd7,0xa3,0x66,0x59,0x69,0x30,0x50,0xf5,0x56,0xb5,0xbf,0x78,0x9e,0x80,0x7c,0x26,0xfa,0x77,0x56,0x92,0xa,0xf2,0x57,0xe,0xfd,0xc0,0xbf,0x4b,0x0,0x68,0x34,0x24,0x60,0x82,0xf3,0x8c,0x90,0xc1,0xa2,0x8a,0xcf,0xe3,0x6b,0x54,0xd0,0xdc,0xf1,0x6c,0xdf,0xc6,0xe4,0x68,0x5c,0xc5,0x47,0x1c,0x1f,0xee,0xd1,0x9e,0xb0,0x48,0x1c,0x8a,0xf5,0x45,0xf3,0x2,0x7a,0x84,0x43,0x3e,0x4b,0x82,0x53,0xd3,0x6d,0xed,0xbb,0x6c,0x82,0x25,0xc0,0x10,0xbb,0x96,0xd6,0xd0,0x44,0x5,0x92,0x85,0x65,0x4a,0x1b,0xef,0x5a,0x1c,0x99,0x1d,0x76,0xf1,0xd4,0x93,0x43,0x80,0x45,0x2b,0xff,0x48,0xbd,0x65,0x40,0x56,0xe1,0x6b,0xe2,0xee,0x3e,0x5,0xa4,0x5,0xcc,0xf0,0x7a,0x1b,0x34,0x54,0x3d,0x5d,0xcd,0x80,0x8c,0x4e,0x40,0x3b,0xb,0x5c,0xe7,0xb4,0x74,0xe1,0xf2,0x39,0x3,0x7f,0xf0,0x96,0x65,0x1d,0x22,0x5b,0x68,0x89,0xa1,0x32,0x46,0x46,0x2f,0xe2,0xe8,0xb1,0x73,0x7a,0x10,0xa5,0xb5,0xd1,0xbb,0x22,0x3f,0xc0,0xc2,0x1b,0x7b,0x8a,0x4d,0xc1,0x28,0x8a,0xad,0x8f,0xd8,0xc2,0x4f,0xe3,0xd2,0x4b,0x29,0xd0,0xb6,0x58,0x66,0x58,0x40,0x43,0x37,0x86,0xa3,0x5a,0x52,0xb4,0xb2,0x9d,0xe5,0xfd,0xd,0xc8,0xd1,0x23,0xd2,0x35,0xb,0xc7,0xdd,0xa9,0x6f,0x78,0x74,0x74,0x86,0xa8,0xcf,0x27,0xe4,0x1e,0xeb,0x1a,0x6e,0x1,0xf0,0xc3,0xa5,0xfc,0x2e,0x77,0xb8,0xfe,0x3b,0x1d,0x76,0xda,0x8e,0x2d,0xfc,0x78,0x5,0xc2,0x5d,0x42,0x4e,0x18,0xf6,0x86,0x23,0x62,0x86,0x95,0xdc,0xe1,0x93,0xe3,0x1e,0x5a,0x33,0x4f,0xa9,0x45,0x20,0x2d,0x19,0x1d,0xdf,0x51,0xcb,0x41,0xd0,0x50,0x47,0xf,0xcc,0x7a,0xbf,0xf1,0x1,0x71,0x26,0x12,0x64,0x4d,0xee,0x1d,0x6c,0xf9,0xc0,0x8d,0x5a,0x1d,0xc,0x72,0x38,0x9,0x3a,0x4,0xbf,0xe5,0x95,0x78,0xb8,0x54,0x1b,0x54,0xa3,0x41,0xdd,0x5f,0x1a,0x20,0xa0,0x88,0x81,0x7c,0x84,0x9,0xc2,0x6e,0xcf,0xa4,0xa4,0x17,0x61,0xdd,0xbc,0x6a,0x43,0xbe,0x5,0xd5,0xc5,0x94,0x5,0x82,0x3f,0x19,0x2b,0xb6,0x55,0x61,0xc7,0x2c,0xd,0x45,0x43,0x38,0x9a,0xd8,0x9d,0x64,0x8d,0xda,0x80,0x5d,0x96,0xa9,0xc9,0x52,0x85,0xc4,0x7c,0x5d,0xf9,0x88,0x87,0x7e,0xc9,0x59,0x34,0xbb,0xfd,0x2e,0x76,0x3,0xde,0xfd,0x5b,0x41,0x4c,0x7f,0x6c,0x7e,0xb9,0xc1,0x36,0x9,0xea,0x2b,0xc3,0x3e,0x12,0xea,0xba,0x90,0x1c,0xcd,0xde,0xb6,0x13,0x7c,0x14,0xc5,0xab,0xbe,0xec,0x60,0xef,0xa6,0x95,0xe4,0x7c,0x27,0x5,0xd8,0xdf,0xa,0xa8,0x97,0xa3,0xb1,0x16,0xb0,0xb0,0x9f,0xcb,0x80,0x84,0x2a,0xb6,0xe2,0xff,0x4a,0x7,0x51,0x3a,0xed,0x10,0xac,0x98,0xfc,0x34,0xd9,0xa2,0xf3,0xdf,0xef,0x46,0xd,0x3b,0xd7,0x1c,0x98,0xa0,0x9,0x9a,0xca,0xc6,0x6b,0x1,0x41,0xce,0x8f,0xc,0xec,0x70,0xae,0x50,0xa0,0xc2,0xbc,0xb5,0x13,0xd7,0x78,0x8f,0x71,0x76,0x33,0x21,0x7b,0x80,0x49,0xe5,0x91,0x63,0x38,0xe3,0x5e,0x6d,0xe3,0x35,0x1a,0x70,0x34,0xe3,0x62,0xf7,0x21,0xc1,0xfe,0x92,0x7a,0x49,0x7d,0x5a,0xfb,0xc1,0x73,0xf0,0xf6,0x66,0x23,0x36,0xa6,0x5b,0xa3,0x9a,0x35,0xeb,0x83,0xa5,0xd7,0x88,0x26,0xfe,0x35,0x26,0x66,0x58,0xad,0x75,0x85,0x47,0x11,0xd4,0x39,0x94,0x93,0x68,0xed,0xb3,0x11,0x40,0xe2,0xe8,0x96,0x53,0xa7,0xe3,0xd,0x4,0x1d,0xe1,0xbf,0x7a,0x76,0xda,0xba,0x14,0xd6,0xc7,0xad,0xa8,0x19,0x53,0x1e,0xe3,0x35,0x1c,0xc7,0x36,0xeb,0x8d,0x5e,0xf4,0x13,0x6,0x1e,0xcf,0x30,0x9b,0x7c,0xfa,0x7a,0xfe,0x74,0x2,0x46,0x13,0xfb,0x1,0x91,0x6e,0xe8,0x87,0x21,0x42,0x97,0xa3,0x4a,0xda,0x4e,0x3f,0x6b,0xff,0x67,0x99,0xcf,0x7a,0x48,0xf6,0x8f,0xc7,0x76,0x2f,0x14,0x15,0xe0,0xb,0xea,0x2d,0xe1,0xec,0xed,0xec,0x14,0xd6,0x80,0x62,0x45,0xe5,0xe,0x58,0x66,0x20,0xd,0xbf,0x21,0x78,0xb6,0xf,0x26,0x99,0x8d,0xa1,0x98,0xfd,0xfd,0x64,0x86,0xc4,0xea,0x3c,0xa8,0xcf,0xf0,0xc1,0x11,0x82,0x77,0xd7,0xd3,0x2d,0x7e,0x38,0x5e,0x62,0xd8,0x4b,0x19,0xc6,0x55,0x82,0x33,0xbc,0x7e,0xc1,0xc2,0xd,0xd0,0xac,0x9f,0x32,0xc1,0x76,0xad,0xf9,0xc9,0x30,0x54,0xc6,0x7,0xe5,0x69,0xb8,0x5a,0x30,0x1,0x25,0x4c,0xc1,0x13,0xa2,0x9e,0x15,0x95,0x48,0x75,0x8b,0x97,0x15,0xce,0x87,0xe0,0xb6,0xe,0x5b,0x94,0x45,0xcb,0x2a,0x6c,0x8e,0xc1,0x27,0x12,0xde,0xc4,0x94,0x3a,0x5c,0x63,0xfb,0x79,0x7b,0xf5,0x88,0xe,0x86,0xa8,0x56,0x77,0x10,0x77,0x82,0x47,0x30,0x81,0xfa,0xa8,0xd2,0xd6,0x80,0xba,0xb,0x1a,0x84,0xcb,0xac,0x6,0xac,0xbf,0xa6,0x57,0xc9,0x14,0xc7,0x1d,0xf7,0xc4,0xe7,0xff,0xb9,0xa5,0xf1,0x4c,0xaa,0xd2,0x9f,0x75,0x58,0x6c,0x4,0x89,0x7f,0x5,0xbd,0xf2,0x5b,0xb,0x76,0x58,0xba,0x6c,0x4a,0xe7,0x91,0x28,0x5f,0xec,0x34,0x3c,0x80,0x6a,0x1a,0xed,0x6e,0x39,0x1c,0xd3,0x23,0x38,0xec,0xa,0x51,0xa0,0x82,0xff,0x1a,0x5a,0x6b,0xaf,0x46,0xeb,0x64,0x92,0xec,0xa5,0xb5,0x3f,0x2,0x0,0xc2,0x46,0xac,0x82,0xaf,0x96,0x1c,0x69,0x4,0x9c,0xe1,0xa1,0xf5,0x2,0xca,0x82,0x8e,0x32,0x4e,0x4f,0x3e,0x6,0x8,0x1c,0xb9,0xc5,0xa7,0xbb,0x4,0xe8,0x3,0xac,0x83,0x89,0xc4,0xed,0x5f,0x9a,0x55,0x4b,0x17,0x79,0x8d,0xce,0x8b,0xff,0xc4,0x9f,0x77,0x1,0xe6,0xee,0x92,0xb4,0xfd,0xc5,0xc8,0x5b,0x7c,0x67,0xc5,0x4,0x94,0x12,0x82,0x8f,0x8e,0x7,0xf0,0x79,0xd1,0x15,0xd0,0x9,0x2e,0xb,0x32,0x98,0xc4,0xec,0xc9,0x82,0xc3,0x59,0x8a,0x2b,0x4e,0x79,0xed,0x39,0x33,0x6f,0x97,0xab,0x1e,0x5e,0xd,0xc2,0x3c,0xc6,0xa3,0x16,0xed,0xd6,0xf8,0xd,0x0,0x6a,0xba};

//#define OUTPUTKEY 1
void test_for_poly_mul(){//已经验证了正确性
    poly a,b,c;
    for(int i=0;i<FPTRU_N;i++){
        a.coeffs[i]=coe1[i];
        b.coeffs[i]=coe2[i];
    }

    poly * a_d;
    poly * b_d;
    poly * c_d;
    cudaEvent_t start, stop;

    HANDLE_ERROR(cudaMalloc((void**)&a_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&b_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&c_d, sizeof(poly)));
    //设备端传输数据
    cudaMemcpy(a_d, &a, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(b_d, &b, sizeof(poly), cudaMemcpyHostToDevice);
    BEFORE_SPEED
    //poly_mul_653_batch_q1_v2<<<1,N_N653/2,0>>>(a_d,a_d,b_d);
    poly_mul_653_batch_q2<<<1,168>>>(a_d,a_d,b_d);
    AFTER_SPEED("all") //all: 2.509824 ms

    cudaMemcpy(&c, a_d, sizeof(poly), cudaMemcpyDeviceToHost);

    cudaDeviceSynchronize();

    for(int i=0;i<FPTRU_N;i++){
        printf("%d,",c.coeffs[i]);
    }
    printf("\n");

    HANDLE_ERROR(cudaFree(a_d));
    HANDLE_ERROR(cudaFree(b_d));
    HANDLE_ERROR(cudaFree(c_d));

}


void test_for_tensor(){//已经验证了正确性
    poly a,b,c;
    for(int i=0;i<FPTRU_N;i++){
        a.coeffs[i]=coe1[i];
        b.coeffs[i]=coe2[i];
    }

    poly * a_d;
    poly * b_d;
    poly * c_d;
    cudaEvent_t start, stop;

    cudaStream_t stream_0;
    HANDLE_ERROR(cudaStreamCreate(&stream_0));

    HANDLE_ERROR(cudaMalloc((void**)&a_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&b_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&c_d, sizeof(poly)));
    //设备端传输数据
    cudaMemcpy(a_d, &a, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(b_d, &b, sizeof(poly), cudaMemcpyHostToDevice);
    
    tensor_poly_mul(c_d,a_d,b_d,stream_0); 

    cudaMemcpy(&c, c_d, sizeof(poly), cudaMemcpyDeviceToHost);

    cudaDeviceSynchronize();

    for(int i=0;i<FPTRU_N;i++){
        printf("%d,",c.coeffs[i]);
    }
    printf("\n");

    HANDLE_ERROR(cudaFree(a_d));
    HANDLE_ERROR(cudaFree(b_d));
    HANDLE_ERROR(cudaFree(c_d));

}

void test_for_tensor_2(){//已经验证了正确性
    poly a,b,c;
    for(int i=0;i<FPTRU_N;i++){
        a.coeffs[i]=coe1[i];
        b.coeffs[i]=coe2[i];
    }

    poly * a_d;
    poly * b_d;
    poly * c_d;
    cudaEvent_t start, stop;

    cudaStream_t stream_0;
    HANDLE_ERROR(cudaStreamCreate(&stream_0));

    HANDLE_ERROR(cudaMalloc((void**)&a_d, sizeof(poly) * 2));
    HANDLE_ERROR(cudaMalloc((void**)&b_d, sizeof(poly) * 2));
    HANDLE_ERROR(cudaMalloc((void**)&c_d, sizeof(poly) * 2));
    //设备端传输数据
    cudaMemcpy(&a_d[0], &a, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(&a_d[1], &a, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(&b_d[0], &b, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(&b_d[1], &b, sizeof(poly), cudaMemcpyHostToDevice);
    
    tensor_poly_mul(c_d,a_d,b_d,stream_0); 

    cudaMemcpy(&c, &c_d[0], sizeof(poly), cudaMemcpyDeviceToHost);

    cudaDeviceSynchronize();

    printf("1\n");
    for(int i=0;i<FPTRU_N;i++){
        printf("%d,",c.coeffs[i]);
    }
    printf("\n");


    cudaMemcpy(&c, &c_d[1], sizeof(poly), cudaMemcpyDeviceToHost);

    cudaDeviceSynchronize();

    printf("2\n");
    for(int i=0;i<FPTRU_N;i++){
        printf("%d,",c.coeffs[i]);
    }
    printf("\n");

    HANDLE_ERROR(cudaFree(a_d));
    HANDLE_ERROR(cudaFree(b_d));
    HANDLE_ERROR(cudaFree(c_d));

}


int zhc(){
    poly a,b,c;
    for(int i=0;i<FPTRU_N;i++){
        a.coeffs[i]=coe1[i];
        b.coeffs[i]=coe2[i];
    }
    
    poly * a_d;
    poly * b_d;
    poly * c_d;
    cudaEvent_t start, stop;

    HANDLE_ERROR(cudaMalloc((void**)&a_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&b_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&c_d, sizeof(poly)));
    //设备端传输数据
    cudaMemcpy(a_d, &a, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(b_d, &b, sizeof(poly), cudaMemcpyHostToDevice);

    BEFORE_SPEED
    poly_mul_653_batch_q1_zhc<<<1,N_N653/2,0>>>(a_d,a_d,b_d);
    AFTER_SPEED("zhc")

    cudaDeviceSynchronize();
    
    HANDLE_ERROR(cudaFree(a_d));
    HANDLE_ERROR(cudaFree(b_d));
    HANDLE_ERROR(cudaFree(c_d));
    
    return 0;
}

void test_for_2222223(){
    poly a,b,c;
    for(int i=0;i<FPTRU_N;i++){
        a.coeffs[i]=coe1[i];
        b.coeffs[i]=coe2[i];
    }

    poly * a_d;
    poly * b_d;
    poly * c_d;
    cudaEvent_t start, stop;

    HANDLE_ERROR(cudaMalloc((void**)&a_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&b_d, sizeof(poly)));
    HANDLE_ERROR(cudaMalloc((void**)&c_d, sizeof(poly)));
    //设备端传输数据
    cudaMemcpy(a_d, &a, sizeof(poly), cudaMemcpyHostToDevice);
    cudaMemcpy(b_d, &b, sizeof(poly), cudaMemcpyHostToDevice);
    BEFORE_SPEED
    poly_mul_653_batch_q1_v3<<<1,168,0>>>(a_d,a_d,b_d);
    AFTER_SPEED("all") //all: 2.509824 ms

    cudaMemcpy(&c, a_d, sizeof(poly), cudaMemcpyDeviceToHost);

    cudaDeviceSynchronize();

    for(int i=0;i<FPTRU_N;i++){
        printf("%d,",c.coeffs[i]);
    }
    printf("\n");

    HANDLE_ERROR(cudaFree(a_d));
    HANDLE_ERROR(cudaFree(b_d));
    HANDLE_ERROR(cudaFree(c_d));
}

//#define OUTPUTKEY 1
//#define OUTPENCAPS 1
//#define OUTDECAPS 1
//下面可以用来验证正确性
int main_0(){
    //test_for_tensor(); //修改batch_size为2
    //test_for_2222223();
    //test_for_poly_mul();
    //zhc();
    /*for(int i=0;i<20;i++){
        test_for_poly_mul();
        zhc();
    }*/

    //return 0;
    //printf("In main\n");
    unsigned char array_pk[FPTRU_KEM_PUBLICKEYBYTES * BATCH_SIZE] = {0}, array_sk[FPTRU_KEM_SECRETKEYBYTES * BATCH_SIZE] = {0};
    unsigned char k1[FPTRU_SHAREDKEYBYTES * BATCH_SIZE] = {0};
    unsigned char ct[FPTRU_KEM_CIPHERTEXTBYTES * BATCH_SIZE] = {0};

    unsigned char k2[FPTRU_SHAREDKEYBYTES * BATCH_SIZE] ={0};

    int res[BATCH_SIZE];



    /*printf("original original pk\n");
    for(int i=0;i<FPTRU_KEM_PUBLICKEYBYTES;i++){
        printf("0x%x,",PK[i]);
    }
    printf("\n\n");*/


    uint64_t hxw1,hxw2;

    //hxw1 = cpucycles();
    //crypto_kem_keygen_single_v2(array_pk,array_sk);
    cudaStream_t stream_0;
    HANDLE_ERROR(cudaStreamCreate(&stream_0));
    double total_time=0;
    hxw1 = cpucycles();
    for(int i=0;i<HXWTEST;i++){
        //float res = crypto_kem_keygen_v2(array_pk,array_sk,stream_0);
        //printf("%i\n",i);
        //hxw1 = cpucycles();
        crypto_kem_keygen_no_inv_batch_stream_ordered_async(array_pk,array_sk,stream_0);
        //total_time += crypto_kem_keygen_no_inv_batch(array_pk,array_sk,stream_0);

        //固定公私钥为一个
        /*for(int j=0;j<BATCH_SIZE;j++){
            for(int k = 0;k<FPTRU_KEM_PUBLICKEYBYTES;k++){
                array_pk[FPTRU_KEM_PUBLICKEYBYTES * j + k] = PK[k];
            }

            for(int k =0;k<FPTRU_KEM_SECRETKEYBYTES;k++){
                array_sk[j * FPTRU_KEM_SECRETKEYBYTES + k] = SK[k];
            }
        }*/


        
        total_time += crypto_kem_encaps_v4(ct,k1,array_pk,stream_0); //现在未固定了随机值
        //total_time += crypto_kem_encaps(ct,k1,array_pk,stream_0); //现在未固定了随机值
        crypto_kem_decaps_v3(k2,ct,array_sk,stream_0,res);
        
        //printf("%f\n",res);s
        //total_time += res;
        printf("解密结果为\n");
        for(int i=0;i<BATCH_SIZE;i++){
            printf("%d,",res[i]);//值为0代表方案成功
        }
        printf("\n");
    }
    hxw2 = cpucycles();

    
    
    //crypto_kem_keygen_small();
    //crypto_kem_keygen_empty();//正常情况下能够完成malloc和free的操作
    //hxw2 = cpucycles();
    //printf("gpu for [%d]keygen  is %llu\n",BATCH_SIZE,(unsigned long long)hxw2-hxw1);
    printf("batch size = %d,%lld,%f\n",BATCH_SIZE,(unsigned long long)(hxw2-hxw1),(float)(hxw2-hxw1)/ (HXWTEST * BATCH_SIZE));
    printf("encaps \n%lf\n",total_time / (BATCH_SIZE*  HXWTEST)); //0.005020 TODO:zhc改回来

#ifdef OUTPUTKEY //验证整个keygen的正确性
    for(int j=0;j<BATCH_SIZE;j++){
        for(int i=0;i<FPTRU_KEM_PUBLICKEYBYTES;i++){
            printf("0x%x,",array_pk[j * FPTRU_KEM_PUBLICKEYBYTES + i]);
        }

        printf("\n\n");
        for(int i=0;i<FPTRU_KEM_SECRETKEYBYTES;i++){//FPTRU_PKE_SECRETKEYBYTES + FPTRU_PKE_PUBLICKEYBYTES;i++){
            printf("0x%x,",array_sk[j * FPTRU_KEM_SECRETKEYBYTES + i]);
        }

        printf("\n\n");
    }
#endif

#ifdef OUTPENCAPS
    for(int j=0;j<BATCH_SIZE;j++){
        printf("result ct\n");
        for(int i=0;i<FPTRU_KEM_CIPHERTEXTBYTES;i++){
            printf("0x%x,",ct[FPTRU_KEM_CIPHERTEXTBYTES * j + i]);
        }
        printf("\n\n");

        printf("result k1\n");
        for(int i=0;i<FPTRU_SHAREDKEYBYTES;i++){
            printf("0x%x,",k1[FPTRU_SHAREDKEYBYTES * j + i]);
        }
        printf("\n\n");
    }
#endif

#ifdef OUTDECAPS
    for(int j=0;j<BATCH_SIZE;j++){
        printf("result k2\n");
        for(int i=0;i<FPTRU_SHAREDKEYBYTES;i++){
            printf("0x%x,",k2[FPTRU_SHAREDKEYBYTES * j + i]);
        }
        printf("\n\n");
    }
#endif
}

/**********下面用于多个stream的调用 start*****************/

#include <thread>
#include <vector>

//#define OUTDECPAS
// 定义参数结构体
struct ThreadArgs {
    unsigned char *array_pk;
    unsigned char *array_sk;
    unsigned char *k1;
    unsigned char *ct;
    unsigned char *k2;
    int * res;
    cudaStream_t stream;
};

struct SpeedResult{
    double keygen,encaps,decaps;
};
// 定义 crypto_kem_keygen 函数
/*extern  float crypto_kem_keygen(unsigned char *array_pk, unsigned char *array_sk, cudaStream_t stream);*/

//extern  void crypto_kem_keygen_no_inv_batch(unsigned char *array_pk,unsigned char *array_sk,cudaStream_t stream);

extern double crypto_kem_keygen_no_inv_batch_stream_ordered_async(unsigned char *array_pk,unsigned char *array_sk,cudaStream_t stream);
extern double crypto_kem_encaps_v4(unsigned char *ct, unsigned char *k, const unsigned char *pk,cudaStream_t stream);
extern double crypto_kem_decaps_v3(unsigned char *k, const unsigned char *ct, const unsigned char *sk,cudaStream_t stream, int *res);

// 线程执行函数
void thread_function_keygen(ThreadArgs *args) {
    crypto_kem_keygen_no_inv_batch_stream_ordered_async(args->array_pk, args->array_sk, args->stream);
}

void thread_function_encaps(ThreadArgs *args) {
    crypto_kem_encaps_v4(args->ct,args->k1,args->array_pk,args->stream);
}

void thread_function_decaps(ThreadArgs *args) {
    crypto_kem_decaps_v3(args->k2, args->ct, args->array_sk,args->stream, args->res);
}

SpeedResult stream_test() {
    SpeedResult res;
    // 定义线程数量
    const int NUM_THREADS = NUM_THREAD;
    // 定义线程数组
    //std::vector<std::thread> threads;
    std::thread threads[NUM_THREADS];
    // 定义参数数组
    std::vector<ThreadArgs> thread_args(NUM_THREADS);
    // 定义 CUDA 流数组
    cudaStream_t streams[NUM_THREADS];

    // 初始化参数和 CUDA 流
    for (int i = 0; i < NUM_THREADS; i++) {
        thread_args[i].array_pk = new unsigned char[sizeof(unsigned char) * FPTRU_KEM_PUBLICKEYBYTES * BATCH_SIZE];
        /*for(int j=0;j<FPTRU_KEM_PUBLICKEYBYTES;j++){
            thread_args[i].array_pk[j]=PK[j];
        }*/
        thread_args[i].array_sk = new unsigned char[sizeof(unsigned char) * FPTRU_KEM_SECRETKEYBYTES * BATCH_SIZE];
        thread_args[i].ct = new unsigned char[sizeof(unsigned char) * FPTRU_KEM_CIPHERTEXTBYTES * BATCH_SIZE];
        thread_args[i].k1 = new unsigned char[sizeof(unsigned char) * FPTRU_SHAREDKEYBYTES * BATCH_SIZE];
        thread_args[i].k2 = new unsigned char[sizeof(unsigned char) * FPTRU_SHAREDKEYBYTES * BATCH_SIZE];
        thread_args[i].res = new int[sizeof(int) * BATCH_SIZE];

        HANDLE_ERROR(cudaStreamCreate(&streams[i]));
        thread_args[i].stream = streams[i];
    }

    uint64_t hxw1,hxw2;
    //+++++++++++++++++++++完成keygen的测速+++++++++++++++++++++++++
    hxw1 = cpucycles();

    // 创建并启动线程
    for (int i = 0; i < NUM_THREADS; i++) {
        //threads.push_back(std::thread(thread_function_keygen, &thread_args[i]));
        threads[i] = std::thread(thread_function_keygen, &thread_args[i]);
    }

    // 等待线程完成
    for (int i = 0; i < NUM_THREADS; i++) {
        threads[i].join();
    }

    hxw2 = cpucycles();

    res.keygen = (double)(hxw2-hxw1)/ (BATCH_SIZE * NUM_THREADS);
    //printf("gpu for [%d]keygen  is %llu\n",BATCH_SIZE,(unsigned long long)hxw2-hxw1);
    //printf("%llu %lf\n",(unsigned long long)(hxw2-hxw1)/ (BATCH_SIZE * NUM_THREADS),res.keygen);
    //+++++++++++++++++++++完成keygen的测速+++++++++++++++++++++++++


#ifdef OUTPUTKEY //验证整个keygen的正确性
    for(int k = 0; k < NUM_THREADS; k++){
        printf("*****%d******\n",k);
        for(int j=0;j<BATCH_SIZE;j++){
            for(int i=0;i<FPTRU_KEM_PUBLICKEYBYTES;i++){
                printf("%x ",thread_args[k].array_pk[j * FPTRU_KEM_PUBLICKEYBYTES + i]);
            }

            printf("\n");
            for(int i=0;i<FPTRU_KEM_SECRETKEYBYTES;i++){
                printf("%x ",thread_args[k].array_sk[j * FPTRU_KEM_SECRETKEYBYTES + i]);
            }

            printf("\n\n\n");
        }
    }
#endif

    //+++++++++++++++++++++完成encaps的测速+++++++++++++++++++++++++
    hxw1 = cpucycles();

    // 创建并启动线程
    for (int i = 0; i < NUM_THREADS; i++) {
        //threads.push_back(std::thread(thread_function_encaps, &thread_args[i]));
        //printf("threads size = %d\n",thread_args.size());
        threads[i] = std::thread(thread_function_encaps, &thread_args[i]);
    }

    // 等待线程完成
    for (int i = 0; i < NUM_THREADS; i++) {
        threads[i].join();
    }

    hxw2 = cpucycles();

    res.encaps = (double)(hxw2-hxw1)/ (BATCH_SIZE * NUM_THREADS);
    //+++++++++++++++++++++完成encaps的测速+++++++++++++++++++++++++


    //+++++++++++++++++++++完成decaps的测速+++++++++++++++++++++++++
    hxw1 = cpucycles();

    // 创建并启动线程
    for (int i = 0; i < NUM_THREADS; i++) {
        threads[i] = std::thread(thread_function_decaps, &thread_args[i]);
    }

    // 等待线程完成
    for (int i = 0; i < NUM_THREADS; i++) {
        threads[i].join();
    }

    hxw2 = cpucycles();

    res.decaps = (double)(hxw2-hxw1)/ (BATCH_SIZE * NUM_THREADS);
    //+++++++++++++++++++++完成decaps的测速+++++++++++++++++++++++++

#ifdef OUTDECPAS
    printf("decaps result\n");
    for (int i = 0; i < NUM_THREADS; i++) {
        for(int j = 0; j < BATCH_SIZE; j++){
            printf("%d,",thread_args[i].res[j]);
        }
        printf("\n");
    }
#endif


    // 销毁 CUDA 流
    for (int i = 0; i < NUM_THREADS; i++) {
        cudaStreamDestroy(streams[i]);
    }

    // 释放参数内存
    for (int i = 0; i < NUM_THREADS; i++) {
        delete[] thread_args[i].array_pk;
        delete[] thread_args[i].array_sk;
        delete[] thread_args[i].ct;
        delete[] thread_args[i].k1;
        delete[] thread_args[i].k2;
        delete[] thread_args[i].res;
    }

    return res;
}


struct KEY {
    unsigned char *array_pk;
    unsigned char *array_sk;
};

/*double stream_exp(){
    float   elapsedTime;
    cudaEvent_t start, stop;
    const int NUM_THREADS = 10;
    cudaStream_t streams[NUM_THREADS];
    std::vector<KEY> pks(NUM_THREADS);
    for(int i=0;i<NUM_THREADS;i++){
        pks[i].array_pk = new unsigned char[sizeof(unsigned char) * FPTRU_KEM_PUBLICKEYBYTES * BATCH_SIZE];
        pks[i].array_sk = new unsigned char[sizeof(unsigned char) * FPTRU_KEM_SECRETKEYBYTES * BATCH_SIZE];
    }
    BEFORE_SPEED
    for(int i=0;i<NUM_THREADS;i++){
        crypto_kem_keygen_tensor_core()
    }



    BEFORE_SPEED
}*/


#define TESTS 100
int main(){
    printf("test num=%d,BATCH_size = %d,NUM_thread=%d\n",TESTS,BATCH_SIZE,NUM_THREAD);
    SpeedResult res_tmp;
    SpeedResult res;
    res.keygen = res.encaps = res.decaps = 0;
    unsigned long long total_time=0;
    for(int i=0;i<TESTS;i++){
        res_tmp = stream_test();
        res.keygen += res_tmp.keygen;
        res.encaps += res_tmp.encaps;
        res.decaps += res_tmp.decaps;
    }
    printf("avarage keygen = %lf\n avarage encaps = %lf\n avarage decaps = %lf\n",res.keygen/TESTS,res.encaps/TESTS,res.decaps/TESTS);
}

/**********下面用于多个stream的调用 end*****************/
/*
int main(){
    montgomery_reduce_n653_cuda()=montgomery_reduce_n653_ptx()
}*/

/*********************************************下面用于测试montgomery的ptx版本
#define NUM_TESTS 1000

__global__ void test_montgomery_reduce(int64_t* inputs, int32_t* outputs_ptx, int32_t* outputs_cuda, int num_tests) {
    int idx = threadIdx.x + blockIdx.x * blockDim.x;
    if (idx < num_tests) {
        int64_t a = inputs[idx];
        outputs_ptx[idx] = montgomery_reduce_n653_ptx(a);
        outputs_cuda[idx] = montgomery_reduce_n653_cuda(a);
    }
}
int main() {
    int64_t* h_inputs = (int64_t*)malloc(NUM_TESTS * sizeof(int64_t));
    int32_t* h_outputs_ptx = (int32_t*)malloc(NUM_TESTS * sizeof(int32_t));
    int32_t* h_outputs_cuda = (int32_t*)malloc(NUM_TESTS * sizeof(int32_t));

    for (int i = 0; i < NUM_TESTS; ++i) {
        h_inputs[i] = rand() % UINT64_MAX;
    }

    int64_t* d_inputs;
    int32_t* d_outputs_ptx;
    int32_t* d_outputs_cuda;

    cudaMalloc(&d_inputs, NUM_TESTS * sizeof(int64_t));
    cudaMalloc(&d_outputs_ptx, NUM_TESTS * sizeof(int32_t));
    cudaMalloc(&d_outputs_cuda, NUM_TESTS * sizeof(int32_t));

    cudaMemcpy(d_inputs, h_inputs, NUM_TESTS * sizeof(int64_t), cudaMemcpyHostToDevice);

    test_montgomery_reduce<<<(NUM_TESTS + 255) / 256, 256>>>(d_inputs, d_outputs_ptx, d_outputs_cuda, NUM_TESTS);

    cudaMemcpy(h_outputs_ptx, d_outputs_ptx, NUM_TESTS * sizeof(int32_t), cudaMemcpyDeviceToHost);
    cudaMemcpy(h_outputs_cuda, d_outputs_cuda, NUM_TESTS * sizeof(int32_t), cudaMemcpyDeviceToHost);

    bool correct = true;
    for (int i = 0; i < NUM_TESTS; ++i) {
        if (h_outputs_ptx[i] != h_outputs_cuda[i]) {
            //if(h_outputs_cuda[i] - h_outputs_ptx[i] != Q_N653){
                printf("Mismatch at index %d: PTX = %d, CUDA = %d\n", i, h_outputs_ptx[i], h_outputs_cuda[i]);
                correct = false;
            //}
        }
    }

    if (correct) {
        printf("All tests passed!\n");
    }

    free(h_inputs);
    free(h_outputs_ptx);
    free(h_outputs_cuda);
    cudaFree(d_inputs);
    cudaFree(d_outputs_ptx);
    cudaFree(d_outputs_cuda);

    return 0;
}
*/